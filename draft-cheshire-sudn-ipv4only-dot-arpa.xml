<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">

<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>

<!-- Check output with <http://tools.ietf.org/tools/idnits/> -->

<!-- used by XSLT processors -->
<!-- For a complete list and description of processing instructions (PIs),
     please see http://xml.resource.org/authoring/README.html. -->
<!-- Below are generally applicable Processing Instructions (PIs) that most I-Ds might want to use.
     (Here they are set differently than their defaults in xml2rfc v1.35) -->

<!-- give errors regarding ID-nits and DTD validation -->
<?rfc strict="yes" ?>

<!-- control the table of contents (ToC) -->
<!-- generate a ToC -->
<?rfc toc="no"?>
<!-- the number of levels of subsections in ToC. default: 3 -->
<?rfc tocdepth="1"?>

<!-- control references -->
<!-- use anchors instead of numbers for refs, i.e, [RFC2119] instead of [1] -->
<?rfc symrefs="yes"?>
<!-- sort the reference entries alphabetically -->
<?rfc sortrefs="no" ?>

<!-- control vertical white space
     (using these PIs as follows is recommended by the RFC Editor) -->
<!-- do not start each main section on a new page -->
<?rfc compact="yes" ?>
<!-- keep one blank line between list items -->
<?rfc subcompact="no" ?>

<!-- encourage use of "xml2rfc" tool -->
<?rfc rfcprocack="yes" ?>
<!-- end of list of popular I-D processing instructions -->

<rfc category="std" docName="draft-cheshire-sudn-ipv4only-dot-arpa-13" ipr="trust200902" updates="7050">
  <front>
    <title abbrev="Special Name ipv4only.arpa">Special Use Domain Name 'ipv4only.arpa'</title>

    <author initials='S.' surname='Cheshire' fullname='Stuart Cheshire'>
      <organization>Apple Inc.</organization>
      <address>
        <postal>
          <street>One Apple Park Way</street>
          <city>Cupertino</city>
          <region>California</region>
          <code>95014</code>
          <country>USA</country>
        </postal>
        <phone>+1 (408) 996-1010</phone>
        <email>cheshire@apple.com</email>
      </address>
    </author>

    <author initials='D.' surname='Schinazi' fullname='David Schinazi'>
      <address>
        <email>dschinazi.ietf@gmail.com</email>
      </address>
    </author>

    <date day='23' month='October' year='2018'/>

    <abstract>
      <t>The specification for
      how a client discovers its local network's NAT64 prefix [RFC7050]
      defines the special name 'ipv4only.arpa' for this purpose,
      but in its Domain Name Reservation Considerations section
      that specification indicates that the name actually has
      no particularly special properties would require special handling, and does not request IANA to record
      the name in the Special-Use Domain Names registry.</t>

      <t>Consequently, despite the well articulated special purpose of the name,
      'ipv4only.arpa' was not recorded in the
      Special-Use Domain Names registry
      as a name with special properties.</t>

      <t>As a result of this omission, in cases where software needs
      to give this name special treatment in order for it to work correctly,
      there was no clear mandate authorizing software authors to implement that
      special treatment. Software implementers were left with the choice
      between not implementing the special behavior necessary for the name
      queries to work correctly, or implementing the special behavior
      and being accused of being noncompliant with some RFC.</t>

      <t>This document describes the special treatment required,
      formally declares the special properties of the name,
      and adds similar declarations for the corresponding reverse mapping names.</t>
    </abstract>
  </front>

  <middle>
    <?rfc needLines="10" ?>
    <section title="Introduction">
      <t>The specification for
      <xref target="RFC7050">how a client discovers its local network's NAT64 prefix</xref>
      defines the special name 'ipv4only.arpa' for this purpose,
      but in its Domain Name Reservation Considerations section
      that specification indicates that the name actually has
      no particularly special properties would require special handling, and does not request IANA to record
      the name in the <xref target="SUDN">Special-Use Domain Names registry</xref>.</t>

      <t>Consequently, despite the well articulated special purpose of the name,
      'ipv4only.arpa' was not recorded in the
      <xref target="SUDN">Special-Use Domain Names registry</xref>
      as a name with special properties.</t>

      <t>This omission was discussed in
      <xref target="RFC8244">the Special-Use Domain Names Problem Statement</xref>.</t>

      <t>As a result of this omission, in cases where software needs
      to give this name special treatment in order for it to work correctly,
      there was no clear mandate authorizing software authors to implement that
      special treatment. Software implementers were left with the choice
      between not implementing the special behavior necessary for the name
      queries to work correctly, or implementing the special behavior
      and being accused of being noncompliant with some RFC.</t>

      <t>This document describes the special treatment required,
      formally declares the special properties of the name,
      and adds similar declarations for the corresponding reverse mapping names.</t>
    <?rfc needLines="24" ?>
    </section>

    <section anchor="terminology" title="Conventions and Terminology Used in this Section">
      <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
      "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY",<vspace />
      and "OPTIONAL" in this section are to be interpreted as described<vspace />
      in "Key words for use in RFCs to Indicate Requirement Levels",<vspace />
      when, and only when, they appear in all capitals, as shown here<vspace />
      <xref target="RFC2119"/> <xref target="RFC8174"/>.</t>
    </section>

    <section title="Specialness of 'ipv4only.arpa'">
      <t>The hostname 'ipv4only.arpa' is peculiar in that it was never intended
      to be treated like a normal hostname.</t>

      <t>A typical client never looks up the IPv4 address records for 'ipv4only.arpa',
      because it is already known, <xref target="RFC7050">by specification</xref>,
      to have exactly two IPv4 address records, 192.0.0.170 and 192.0.0.171.
      No client ever has to look up the name in order to learn those two addresses.</t>

      <t>In contrast, clients often look up the IPv6 AAAA address records for
      'ipv4only.arpa', which is contrary to general DNS expectations, given
      that it is already known, <xref target="RFC7050">by specification</xref>,
      that no such IPv6 AAAA address records exist. And yet, clients expect to
      receive, and do in fact receive, positive answers for these IPv6 AAAA
      address records that are known to not exist.</t>

      <?rfc needLines="3" ?>
      <t>This is clearly not a typical DNS name. In normal operation, clients never query for
      the two records that do in fact exist; instead clients query for records that
      are known to not exist, and then get positive answers to those abnormal queries.
      Clients are using DNS to perform queries for this name, but they are certainly not
      using DNS to learn legitimate answers from the name's legitimate authoritative server.
      Instead, the DNS protocol has, in effect, been co-opted as
      an impromptu client-to-middlebox communication protocol, to communicate with the
      NAT64/DNS64 <xref target="RFC6146"/> <xref target="RFC6147"/> gateway,
      if present, and request that it disclose the prefix it is using for IPv6 address synthesis.</t>

      <t>It is this use of specially-crafted DNS queries as an impromptu
      client-to-middlebox communication protocol that makes the name 'ipv4only.arpa'
      most definitely a special name, and one that needs to
      be listed in IANA's registry along with
      <xref target="SUDN">other DNS names that have special uses</xref>.</t>
    <?rfc needLines="14" ?>
    </section>

    <section title="Consequences of 'ipv4only.arpa' not being declared special">
      <t>As a result of <xref target="RFC7050">the original specification</xref>
      not formally declaring 'ipv4only.arpa' to have special properties,
      there was no clear mandate for DNS software to treat this name
      specially. Consequently, queries for this name had to be handled normally,
      resulting in unnecessary
      IPv6 address record queries (DNS qtype "AAAA", always returning negative responses) and
      IPv4 address record queries (DNS qtype "A", always returning the same positive responses)
      to the authoritative 'arpa' name servers.</t>

      <t>Having millions of devices around the world issue these queries generated
      additional load on the authoritative 'arpa' name servers, which was
      redundant when the name 'ipv4only.arpa' is defined, by Internet Standard,
      to have exactly two IPv4 address records, 192.0.0.170 and 192.0.0.171,
      and no other IPv4 or IPv6 address records.</t>

      <t>Also, at times, for reasons that remain
      unclear, the authoritative 'arpa' name servers have been observed to be slow or unresponsive.
      The failures of these 'ipv4only.arpa' queries result in unnecessary failures
      of software that depends on them for <xref target="RFC6147">DNS64</xref> address synthesis.</t>

      <t>Even when the authoritative 'arpa' name servers are operating correctly,
      having to perform an unnecessary query to obtain an answer that is already
      known in advance can add precious milliseconds of delay.</t>

      <t>A more serious problem occurs when a device is configured to use a recursive resolver
      other than the one it learned from the network.</t>

      <t>Typically a device joining a NAT64
      network will learn the recursive resolver recommended for that network either
      via <xref target="RFC8106">IPv6 Router Advertisement Options for DNS Configuration</xref>
      or via <xref target="RFC3646">DNS Configuration options for DHCPv6</xref>.
      On a NAT64 network it is essential that the client use the
      DNS64 recursive resolver recommended for that network, since only that recursive resolver can
      be relied upon to know the appropriate prefix(es) to use for synthesizing IPv6
      addresses that will be acceptable to the NAT64 gateway.</t>

      <t>However, it is increasingly common for users to manually override their
      default DNS configuration because they wish to use some other public recursive
      resolver on the Internet, which may offer better speed, better reliability,
      or better privacy than the local network's default recursive resolver.
      At the time of writing, examples of widely known public recursive resolver services
      include 1.1.1.1, 8.8.8.8, and 9.9.9.9.</t>

      <t>Another common scenario is the use of corporate VPN client software.
      The local network's recursive resolver will typically
      be unable to provide answers for the company's private internal host names,
      so VPN client software overrides the
      local network's default configuration,
      to divert some or all DNS requests to the company's own private internal
      recursive resolver, reached through the VPN tunnel.
      As with the case described above of public recursive resolver services,
      the company's private internal recursive resolver cannot be expected to be able
      to synthesize IPv6 addresses correctly for use with the local network's NAT64 gateway,
      because the company's private internal recursive resolver is unlikely to be aware
      of the NAT64 prefix in use on the NAT64 network to which the client device is currently attached.
      It is clear that a single recursive resolver cannot meet both needs.
      The local network's recursive resolver cannot give answers for some
      company's private internal host names, and some company's private internal
      recursive resolver cannot give correctly synthesized IPv6 addresses
      suitable for the local network's NAT64 gateway.</t>

      <t>The conflict here arises because DNS is being used for two unrelated purposes.
      The first purpose is retrieving data from a (nominally) global database --
      generally retrieving the IP address(es) associated with a hostname.
      The second purpose is using the DNS protocol as a middlebox communication
      protocol, to interrogate the local network infrastructure to discover
      the IPv6 prefix(es) in use by the local NAT64 gateway for address synthesis.</t>

      <t>This document leverages operational experience to update the
      <xref target="RFC6761">Domain Name Reservation Considerations</xref> section
      of <xref target="RFC7050">the earlier specification</xref>
      with one that
      accurately lists the actual special properties of the name 'ipv4only.arpa',
      so that software can legitimately implement the correct behavior necessary
      for better performance, better reliability, and correct operation.</t>
    <?rfc needLines="19" ?>
    </section>

    <section title="Security Considerations">
      <t>One of the known concerns with DNS64 is that
      it conflicts with DNSSEC. If DNSSEC is used to assert cryptographically that a name
      has no IPv6 AAAA records, then this interferes with using DNS64 address synthesis
      to assert that those nonexistent IPv6 AAAA records do exist.</t>

      <t>Section 3 of the <xref target="RFC6147">DNS64 specification</xref>
      discusses this:
<figure><artwork>
   ... DNS64 receives a query with the DO bit set and
   the CD bit set. In this case, the DNS64 is supposed
   to pass on all the data it gets to the query initiator.
   This case will not work with DNS64, unless the
   validating resolver is prepared to do DNS64 itself.</artwork></figure></t>

      <t>The <xref target="RFC7050">NAT64 Prefix Discovery specification</xref>
      provides the mechanism for the query initiator to learn the NAT64 prefix
      so that it can do its own validation and DNS64 synthesis as described above.
      With this mechanism the client can
      (i) interrogate the local NAT64/DNS64 gateway with an 'ipv4only.arpa'
      query to learn the IPv6 address synthesis prefix,
      (ii) query for the (signed) IPv4 address records itself, and validate the response, and then
      (iii) perform its own IPv6 address synthesis locally,
      combining the IPv6 address synthesis prefix learned from the local NAT64/DNS64 gateway
      with the validated DNSSEC-signed data learned from the global Domain Name System.</t>

      <t>It is conceivable that over time, if DNSSEC adoption continues to grow, the
      majority of clients could move to this validate-and-synthesize-locally
      model, which reduces the DNS64 machinery to the vestigial role of
      simply responding to the 'ipv4only.arpa' query to report the local
      IPv6 address synthesis prefix. In no case does the client care what
      answer(s) the authoritative 'arpa' name servers might give for that query.
      The 'ipv4only.arpa' query is being used purely as a local
      client-to-middlebox communication message.</t>

      <t>This approach is even more attractive if it does not create
      an additional dependency on the authoritative 'arpa' name
      servers to answer a query that is unnecessary
      because the NAT64/DNS64 gateway already knows the answer
      before it even issues the query. Avoiding this unnecessary
      query improves performance and reliability for the client,
      and reduces unnecessary load for the authoritative 'arpa' name servers.</t>

      <t>Hard-coding the known answers for
      'ipv4only.arpa' IPv4 address record queries (DNS qtype "A") in
      recursive resolvers also reduces the risk of malicious devices
      intercepting those queries and returning incorrect answers.
      Because the 'ipv4only.arpa' zone has to be an insecure delegation (see below)
      DNSSEC cannot be used to protect these answers from tampering
      by malicious devices on the path.</t>

      <t>With respect to the question of whether 'ipv4only.arpa' should be
      a secure or insecure delegation,
      there are two paths through the network to consider:
      The path from the authoritative server to the DNS64 recursive resolver,
      and the path from the DNS64 recursive resolver to the ultimate client.
      On either or both paths there may be one or more DNS64-unaware
      recursive resolvers.</t>

      <t>The path from the authoritative server to the DNS64 recursive resolver
      (queries for IPv4 address records)
      need not be protected by DNSSEC, because the DNS64 recursive resolver
      already knows, by specification, what the answers are.
      In principle, if this were a secure delegation, and 'ipv4only.arpa' were
      a signed zone, then the path from the authoritative server to the DNS64
      recursive resolver would still work, but DNSSEC is not necessary here.
      Run-time cryptographic signatures are not needed to verify compile-time constants.</t>

      <t>The path from the DNS64 recursive resolver to the ultimate client
      (queries for IPv6 address records)
      *cannot* be protected by DNSSEC, because the DNS64 recursive resolver
      is synthesizing IPv6 address answers, and does not possess the secret
      key required to sign those answers.</t>

      <t>Consequently, the 'ipv4only.arpa' zone MUST be an insecure delegation,
      to give NAT64/DNS64 gateways the freedom to synthesize answers to those
      queries at will, without the answers being rejected by DNSSEC-capable
      resolvers.
      DNSSEC-capable resolvers that follow this specification
      MUST NOT attempt to validate answers received in response to
      queries for the IPv6 AAAA address records for 'ipv4only.arpa'.</t>

      <t>The original <xref target="RFC7050">NAT64 Prefix Discovery specification</xref>
      stated, incorrectly:
<figure><artwork>
   A signed "ipv4only.arpa." allows validating DNS64 servers
   (see [RFC6147] Section 3, Case 5, for example) to detect
   malicious AAAA resource records.  Therefore, the zone
   serving the well-known name has to be protected with DNSSEC.</artwork></figure></t>

      <t>This document updates <xref target="RFC7050">the previous specification</xref>
      to correct that error. The 'ipv4only.arpa' zone MUST be an insecure delegation.</t>

    </section>

    <section title="IANA Considerations">

      <?rfc subcompact="yes" ?>
      <t>[Once published] IANA has recorded the following names in the<vspace />
      <xref target="SUDN">Special-Use Domain Names registry</xref>:
        <list style='empty'>
          <t>ipv4only.arpa.</t>
          <t>170.0.0.192.in&nbhy;addr.arpa.</t>
          <t>171.0.0.192.in&nbhy;addr.arpa.</t>
        </list>
      </t>

      <t>IANA has recorded the following IPv4 addresses in the<vspace />
      <xref target="SUv4">IPv4 Special-Purpose Address Registry</xref>:
        <list style='empty'>
          <t>192.0.0.170</t>
          <t>192.0.0.171</t>
        </list>
      </t>
      <?rfc subcompact="no" ?>
<?rfc needLines="20" ?>
    </section>

    <section title="Domain Name Reservation Considerations">

      <section title="Special Use Domain Name 'ipv4only.arpa'">
        <t>The name 'ipv4only.arpa' is defined, by Internet Standard, to have
        two IPv4 address records with rdata 192.0.0.170 and 192.0.0.171.</t>

        <t>When queried via a <xref target="RFC6147">DNS64</xref> recursive resolver, the name
        'ipv4only.arpa' is also defined to have IPv6 AAAA records,
        with rdata synthesized from a combination of the NAT64 IPv6 prefix(es)
        and the IPv4 addresses 192.0.0.170 and 192.0.0.171.
        This can return more than one pair of IPv6 addresses
        if there are multiple NAT64 prefixes.</t>

        <t>The name 'ipv4only.arpa' has no other IPv4 or IPv6 address records.<vspace />
        There are no subdomains of 'ipv4only.arpa'. All names falling below
        'ipv4only.arpa' are defined to be nonexistent (NXDOMAIN).</t>

        <t>The name 'ipv4only.arpa' is special to<vspace />
        (a) client software wishing to perform DNS64 address synthesis,<vspace />
        (b) APIs responsible for retrieving the correct information, and<vspace />
        (c) the DNS64 recursive resolver responding to such requests.<vspace />
        These three considerations are listed in items 2, 3 and 4 below:</t>

        <t>
          <list style="numbers">
            <t>Normal users should never have reason to encounter the 'ipv4only.arpa' domain name.
            If they do, they should expect queries for 'ipv4only.arpa' to result in
            <xref target="RFC7050">the answers required by the specification</xref>.
            Normal users have no need to know that 'ipv4only.arpa' is special.</t>

            <t>Application software may explicitly use the name 'ipv4only.arpa' for NAT64/DNS64
            address synthesis, and expect to get
            <xref target="RFC7050">the answers required by the specification</xref>.
            If application software encounters the name 'ipv4only.arpa' in the normal
            course of handling user input, the application software should resolve
            that name as usual and need not treat it in any special way.</t>

            <t>Name resolution APIs and libraries MUST recognize
            'ipv4only.arpa' as special and MUST give it special treatment.
            <vspace blankLines="1"/>
            Learning a network's NAT64 prefix is by its nature an interface-specific
            operation, and the special DNS query used to learn this interface-specific
            NAT64 prefix MUST be sent to the
            DNS recursive resolver address(es) the client learned via the configuration
            machinery for that specific client interface.
            One implication of this is that,
            on any host with multiple physical interfaces (e.g., cellular data and Wi-Fi)
            and/or multiple virtual interfaces (e.g., VPN tunnels),
            for a client to learn the NAT64 prefix in use on a particular interface,
            the DNS name resolution APIs used to look up the IPv6 addresses for
            'ipv4only.arpa' MUST include a parameter for the client to specify
            on which interface to perform this query.
            The NAT64 prefix is a per-interface property, not a per-device property.
            <vspace blankLines="1"/>
            Regardless of any manual client DNS configuration, DNS overrides
            configured by VPN client software, or any other mechanisms that influence
            the choice of the client's recursive resolver address(es)
            (including client devices that run their own local recursive resolver and use
            the loopback address as their configured recursive resolver address)
            all queries for 'ipv4only.arpa' and any subdomains of that name
            MUST be sent to the recursive resolver learned from the network interface in question
            via <xref target="RFC8106">IPv6 Router Advertisement Options for DNS Configuration</xref>
            or via <xref target="RFC3646">DNS Configuration options for DHCPv6</xref>.
            Because DNS queries for 'ipv4only.arpa' are actually a special middlebox
            communication protocol, it is essential that they go to the correct middlebox
            for the interface in question, and failure to honor this requirement would cause failure of
            the <xref target="RFC7050">NAT64 Prefix Discovery mechanism</xref>.
            <vspace blankLines="1"/>
            DNSSEC-capable resolvers MUST NOT attempt to validate answers received
            in response to queries for the IPv6 AAAA address records for 'ipv4only.arpa',
            since, by definition, any such answers are generated by the local network's
            NAT64/DNS64 gateway, not the authoritative server responsible for that name.
            </t>

<?rfc needLines="5" ?>
            <t>For the purposes of this section, recursive resolvers fall into two categories.
            The first category is the traditional recursive resolvers that are in widespread use today.
            The second category is DNS64 recursive resolvers, whose purpose is to synthesize IPv6 address records.
            <vspace blankLines="1" />
            Traditional recursive resolvers SHOULD NOT recognize 'ipv4only.arpa'
            as special or give that name, or subdomains of that name, any special treatment.
            The rationale for this is that a traditional recursive resolver,
            such as built in to a home gateway, may itself be downstream of a DNS64 recursive resolver.
            Passing through the 'ipv4only.arpa' queries to the upstream DNS64 recursive resolver will allow
            the correct NAT64 prefix to be discovered.
            <vspace blankLines="1" />
            All DNS64 recursive resolvers MUST recognize 'ipv4only.arpa'
            as special and MUST NOT attempt to look up NS records for it, or otherwise
            query authoritative name servers in an attempt to resolve this name.
            Instead, DNS64 recursive resolvers MUST act as authoritative for this domain
            and generate immediate responses for all such queries.
            <vspace blankLines="1" />
            DNS64 recursive resolvers MUST generate
            the 192.0.0.170 and 192.0.0.171 responses for IPv4 address queries (DNS qtype "A"),
            the appropriate synthesized IPv6 address record responses for IPv6 address queries (DNS qtype "AAAA"),
            and a negative ("no&nbsp;error&nbsp;no&nbsp;answer") response for all other query types.
            <vspace blankLines="1" />
            For all subdomains of 'ipv4only.arpa', DNS64 recursive resolvers MUST generate immediate NXDOMAIN responses.
            All names falling below 'ipv4only.arpa' are defined to be nonexistent.
            <vspace blankLines="1" />
            An example configuration for BIND 9 showing how to achieve the desired result
            is given in <xref target="app-a" format="none">Appendix A</xref>.
            <vspace blankLines="1" />
            Note that this is *not* a locally served zone in the usual sense of that term
            <xref target="RFC6303"/> because this rule applies *only* to DNS64 recursive resolvers,
            not *all* DNS recursive resolvers.
            </t>

            <t>Traditional authoritative name server software need not recognize
            'ipv4only.arpa' as special or handle it in any special way.<vspace />
            Recursive resolvers SHOULD routinely act as
            authoritative for this name and return the results described
            above. Only the administrators of the 'arpa' namespace need to
            explicitly configure their actual authoritative name servers to be
            authoritative for this name
            and to generate the appropriate answers; all other authoritative
            name servers will not be configured to know anything about this name
            and will reject queries for it, as they would reject queries for any
            other name about which they have no information.</t>

            <t>Generally speaking, operators of authoritative name servers need
            not know anything about the name 'ipv4only.arpa', just as they do not need
            to know anything about any other names they are not responsible for.
            Operators of authoritative name servers who are configuring their name servers
            to be authoritative for this name MUST understand that 'ipv4only.arpa' is
            a special name, with records rigidly specified by Internet Standard
            (generally this applies only to the administrators of the 'arpa' namespace).</t>

            <t>DNS Registries/Registrars need not know anything about the
            name 'ipv4only.arpa', just as they do not need to know
            anything about any other name they are not responsible for.
            Only the administrators of the 'arpa' namespace need to be aware
            of this name's purpose and how it should be configured.
            In particular, 'ipv4only.arpa' MUST be created as an insecure delegation,
            to allow DNS64 recursive resolvers to create synthesized AAAA answers
            within that zone. Making the 'ipv4only.arpa' zone a secure delegation would make it impossible
            for DNS64 recursive resolvers to create synthesized AAAA answers that
            won't fail DNSSEC validation, thereby defeating the entire purpose of the 'ipv4only.arpa' name.
            </t>
          </list>
        </t>
<?rfc needLines="12" ?>
      </section>

      <section title="Names '170.0.0.192.in&nbhy;addr.arpa' and '171.0.0.192.in&nbhy;addr.arpa'">
        <t>Since the IPv4 addresses 192.0.0.170 and 192.0.0.171 are defined
        to be special, and are listed in the
        <xref target="SUv4">IPv4 Special-Purpose Address Registry</xref>,
        the corresponding reverse mapping names in the in&nbhy;addr.arpa domain
        are similarly special.</t>

        <t>The name '170.0.0.192.in&nbhy;addr.arpa' is defined, by Internet Standard,
        to have only one DNS record, type PTR, with rdata 'ipv4only.arpa'.</t>

        <t>The name '171.0.0.192.in&nbhy;addr.arpa' is defined, by Internet Standard,
        to have only one DNS record, type PTR, with rdata 'ipv4only.arpa'.</t>

        <t>There are no subdomains of '170.0.0.192.in&nbhy;addr.arpa' or '171.0.0.192.in&nbhy;addr.arpa'.
        All names falling below these names are defined to be nonexistent (NXDOMAIN).</t>

        <t>Practically speaking these two names are rarely used, but to the extent that
        they may be, they are special only to resolver APIs and libraries, as
        described in item 3 below:

          <list style="numbers">
            <t>Normal users should never have reason to encounter these two reverse mapping names.
            However, if they do, queries for these reverse mapping names should
            return the expected answer 'ipv4only.arpa'.
            Normal users have no need to know that these reverse mapping names are special.</t>

            <t>Application software SHOULD NOT recognize these two reverse mapping
            names as special, and SHOULD NOT treat them differently.<vspace />
            For example, if the user were to issue the Unix command "host&nbsp;192.0.0.170"
            then the "host" command should call the name resolution API or library as usual and display the
            result that is returned.</t>

            <t>Name resolution APIs and libraries SHOULD recognize these two reverse
            mapping names as special and generate the required responses locally.
            For the names '170.0.0.192.in&nbhy;addr.arpa' and '171.0.0.192.in&nbhy;addr.arpa'
            PTR queries yield the result 'ipv4only.arpa';
            all other query types yield a negative ("no&nbsp;error&nbsp;no&nbsp;answer") response.
            For all subdomains of these two reverse mapping domains, all queries yield an NXDOMAIN response.
            All names falling below these two reverse mapping domains are defined to be nonexistent.
            <vspace blankLines="1" />
            This local self-contained generation of these responses is to avoid
            placing unnecessary load on the authoritative 'in&nbhy;addr.arpa' name servers.</t>

<?rfc needLines="12" ?>
            <t>Recursive resolvers SHOULD NOT recognize these two reverse mapping
            names as special and SHOULD NOT, by default, give them any special treatment.</t>

            <t>Traditional authoritative name server software need not
            recognize these two reverse mapping names as special or
            handle them in any special way.
            <vspace blankLines="1" />
            As a practical matter, only the administrators of the '192.in&nbhy;addr.arpa' namespace
            will configure their name servers to be authoritative for these names
            and to generate the appropriate answers; all other authoritative
            name servers will not be configured to know anything about these names
            and will reject queries for them as they would reject queries for any
            other name about which they have no information.</t>

            <t>Generally speaking, operators of authoritative name servers need
            not know anything about these two reverse mapping names, just as they do not need
            to know anything about any other names they are not responsible for.
            Operators of authoritative name servers who are configuring their name servers
            to be authoritative for this name MUST understand that these two reverse
            mapping names are special, with answers specified by Internet Standard
            (generally this applies only to the administrators of the '192.in&nbhy;addr.arpa' namespace).</t>

            <t>DNS Registries/Registrars need not know anything about
            these two reverse mapping names, just as they do not need to know
            anything about any other name they are not responsible for.
            Only the administrators of the '192.in&nbhy;addr.arpa' namespace need
            to be aware of the purpose of these two names.</t>
          </list>
        </t>

<?rfc needLines="20" ?>
        <section title="ip6.arpa Reverse Mapping PTR Records">
          <t>For all IPv6 addresses synthesized by a DNS64 recursive resolver,
          the DNS64 recursive resolver is responsible for
          synthesizing the appropriate 'ip6.arpa' reverse mapping PTR records too,
          if it chooses to provide reverse mapping PTR records.
          The same applies to the synthesized IPv6 addresses corresponding
          to the IPv4 addresses 192.0.0.170 and 192.0.0.171.</t>

          <t>Generally a DNS64 recursive resolver synthesizes
          appropriate 'ip6.arpa' reverse mapping PTR records by extracting
          the embedded IPv4 address from the encoded IPv6 address,
          performing a reverse mapping PTR query for that IPv4 address,
          and then synthesizing a corresponding 'ip6.arpa' reverse mapping
          PTR record containing the same rdata.</t>

          <t>In the case of synthesized IPv6 addresses corresponding
          to the IPv4 addresses 192.0.0.170 and 192.0.0.171,
          the DNS64 recursive resolver does not issue reverse mapping queries
          for those IPv4 addresses, but instead, according to rule 3 above,
          immediately returns the answer 'ipv4only.arpa'.</t>

          <t>In the case of a client that uses the 'ipv4only.arpa' query to discover the
          IPv6 prefixes in use by the local NAT64 gateway, and then proceeds to perform
          its own address synthesis locally (which has benefits such as allowing DNSSEC validation),
          that client MUST also synthesize 'ip6.arpa' reverse mapping PTR
          records for those discovered prefix(es), according to the rules above:
          When a client's name resolution APIs and libraries receive a request
          to look up an 'ip6.arpa' reverse mapping PTR record for an address that
          falls within one of the discovered NAT64 address synthesis prefixes,
          the software extracts the embedded IPv4 address and then,
          for IPv4 addresses 192.0.0.170 and 192.0.0.171, returns the fixed answer 'ipv4only.arpa',
          and for all other IPv4 addresses performs a reverse mapping PTR query for
          the IPv4 address, and then synthesizes a corresponding 'ip6.arpa'
          reverse mapping PTR record containing the same rdata.</t>

<?rfc needLines="38" ?>
        </section>
      </section>
    </section>

    <section anchor="Acknowledgements" title="Acknowledgements">
      <t>Thanks to Jouni Korhonen, Teemu Savolainen, and Dan Wing, for devising
      the <xref target="RFC7050">NAT64 Prefix Discovery mechanism</xref>,
      and for their feedback on this document.</t>

      <t>Thanks to Geoff Huston for his feedback on this document.</t>

      <t>Thanks to Erik Kline for pointing out that the in&nbhy;addr.arpa names are special too.</t>

      <t>Thanks to Marc Andrews for pointing out the reasons why the 'ipv4only.arpa'
      zone MUST be an insecure delegation in order for the
      <xref target="RFC7050">NAT64 Prefix Discovery mechanism</xref> to work.</t>

      <t>Thanks particularly to Lorenzo Colitti for an especially spirited hallway discussion at
      IETF 96 in Berlin, which lead directly to significant improvements in how this
      document presents the issues.</t>

      <t>Thanks to Dave Thaler and Warren Kumari for generously helping
      shepherd this document through the publication process.</t>
    </section>

  </middle>

  <back>
    <?rfc needLines="38" ?>
    <references title="Normative References">
      <?rfc include="reference.RFC.2119" ?>
      <?rfc include="reference.RFC.3646" ?>
      <?rfc include="reference.RFC.6146" ?>
      <?rfc include="reference.RFC.6147" ?>
      <?rfc include="reference.RFC.6761" ?>
      <?rfc include="reference.RFC.7050" ?>
      <?rfc include="reference.RFC.8106" ?>
      <?rfc include="reference.RFC.8174" ?>
    </references>

    <references title="Informative References">

      <?rfc include="reference.RFC.6303" ?>
      <?rfc include="reference.RFC.8244" ?>

      <reference anchor="SUDN"
      target="https://www.iana.org/assignments/special-use-domain-names/">
        <front>
          <title>Special-Use Domain Names Registry</title>
          <author/>
          <date/>
        </front>
      </reference>

      <reference anchor="SUv4"
      target="https://www.iana.org/assignments/iana-ipv4-special-registry/">
        <front>
          <title>IANA IPv4 Special-Purpose Address Registry</title>
          <author/>
          <date/>
        </front>
      </reference>

    </references>

<?rfc needLines="40" ?>
    <section anchor="app-a" title="Example BIND 9 Configuration">
      <t>A BIND 9 recursive resolver can be configured to
      act as authoritative for the necessary DNS64 names as described below.</t>

      <t>In /etc/named.conf the following line is added:
      <figure><artwork>
   zone "ipv4only.arpa"            { type master; file "ipv4only"; };</artwork></figure></t>

      <t>The file /var/named/ipv4only is created with the following content:
      <figure><artwork>
   $TTL 86400               ; Default TTL 24 hours
   @ IN SOA nameserver.example. admin.nameserver.example. (
            2016052400      ; Serial
            7200            ; Refresh ( 7200 = 2 hours)
            3600            ; Retry   ( 3600 = 1 hour)
            15724800        ; Expire  (15724800 = 6 months)
            60              ; Minimum
            )
   @ IN NS  nameserver.example.

   @ IN A    192.0.0.170
   @ IN A    192.0.0.171
   @ IN AAAA 64:ff9b::192.0.0.170 ; If not using Well-Known Prefix
   @ IN AAAA 64:ff9b::192.0.0.171 ; place chosen NAT64 prefix here</artwork></figure></t>

    </section>

  </back>
</rfc>
